package iotago

// Code generated by go generate; DO NOT EDIT. Check gen/ directory instead.

import (
	"bytes"
	"encoding/binary"
	"encoding/hex"
	"fmt"
	{{if index .Features "ids"}} "sort" {{end}}
	"sync"
{{if eq (index .Features "output") false}}

	"golang.org/x/crypto/blake2b"
{{end}}

	"github.com/iotaledger/hive.go/ierrors"
	"github.com/iotaledger/iota.go/v4/hexutil"
	{{if index .Features "output"}}"github.com/iotaledger/hive.go/serializer/v2"{{end}}
)

const (
{{if index .Features "output"}}
	// OutputIndexLength defines the length of an OutputIndex.
	OutputIndexLength = serializer.UInt16ByteSize
	// OutputIDLength defines the length of an OutputID.
	OutputIDLength = TransactionIDLength + OutputIndexLength
{{else}}
	{{.Name}}Length = IdentifierLength + SlotIndexLength
{{end}}
)

var (
	Empty{{.Name}} = {{.Name}}{}
)

{{if index .Features "output"}}
// {{.Name}} is a 32 byte hash value together with an 4 byte slot index and a 2 byte output index.
{{else}}
// {{.Name}} is a 32 byte hash value together with an 4 byte slot index.
{{end -}}
type {{.Name}} [{{.Name}}Length]byte

{{if eq (index .Features "output") false}}
// {{.Name}}RepresentingData returns a new {{.Name}} for the given data by hashing it with blake2b and associating it with the given slot index.
func {{.Name}}RepresentingData(slot SlotIndex, data []byte) {{.Name}} {
	return New{{.Name}}(slot, blake2b.Sum256(data))
}

func New{{.Name}}(slot SlotIndex, idBytes Identifier) {{.Name}} {
	{{.Receiver}} := {{.Name}}{}
	copy({{.Receiver}}[:], idBytes[:])
	binary.LittleEndian.PutUint32({{.Receiver}}[IdentifierLength:], uint32(slot))

	return {{.Receiver}}
}
{{end}}

// {{.Name}}FromHexString converts the hex to a {{.Name}} representation.
func {{.Name}}FromHexString(hex string) ({{.Name}}, error) {
	b, err := hexutil.DecodeHex(hex)
	if err != nil {
		return Empty{{.Name}}, err
	}

	s, _, err := {{.Name}}FromBytes(b)

	return s, err
}

// IsValid{{.Name}} returns an error if the passed bytes are not a valid {{.Name}}, otherwise nil.
func IsValid{{.Name}}(b []byte) error {
	if len(b) != {{.Name}}Length {
		return ierrors.Errorf("invalid {{firstLower .Name}} length: expected %d bytes, got %d bytes", {{.Name}}Length, len(b))
	}

	return nil
}

// {{.Name}}FromBytes returns a new {{.Name}} represented by the passed bytes.
func {{.Name}}FromBytes(b []byte) ({{.Name}}, int, error) {
	if err := IsValid{{.Name}}(b); err != nil {
		return Empty{{.Name}}, 0, err
	}

	return {{.Name}}(b), {{.Name}}Length, nil
}

// Must{{.Name}}FromHexString converts the hex to a {{.Name}} representation.
func Must{{.Name}}FromHexString(hex string) {{.Name}} {
	{{.Receiver}}, err := {{.Name}}FromHexString(hex)
	if err != nil {
		panic(err)
	}

	return {{.Receiver}}
}

func ({{.Receiver}} {{.Name}}) Bytes() ([]byte, error) {
	return {{.Receiver}}[:], nil
}

func ({{.Receiver}} {{.Name}}) MarshalText() (text []byte, err error) {
	dst := make([]byte, hex.EncodedLen(len(Empty{{.Name}})))
	hex.Encode(dst, {{.Receiver}}[:])

	return dst, nil
}

func ({{.Receiver}} *{{.Name}}) UnmarshalText(text []byte) error {
	_, err := hex.Decode({{.Receiver}}[:], text)

	return err
}

// Empty tells whether the {{.Name}} is empty.
func ({{.Receiver}} {{.Name}}) Empty() bool {
	return {{.Receiver}} == Empty{{.Name}}
}

// ToHex converts the Identifier to its hex representation.
func ({{.Receiver}} {{.Name}}) ToHex() string {
	return hexutil.EncodeHex({{.Receiver}}[:])
}

func ({{.Receiver}} {{.Name}}) String() string {
	return fmt.Sprintf("{{.Name}}(%s:%d)", {{.Receiver}}.Alias(), {{.Receiver}}.Slot())
}

func ({{.Receiver}} {{.Name}}) Slot() SlotIndex {
	return SlotIndex(binary.LittleEndian.Uint32({{.Receiver}}[IdentifierLength:]))
}


{{if index .Features "output"}}
// Index returns the index of the Output this OutputID references.
func (outputID OutputID) Index() uint16 {
	return binary.LittleEndian.Uint16(outputID[TransactionIDLength:])
}
{{else}}
// Index returns a slot index to conform with hive's IndexedID interface.
func ({{.Receiver}} {{.Name}}) Index() SlotIndex {
return {{.Receiver}}.Slot()
}
{{end}}

func ({{.Receiver}} {{.Name}}) Identifier() Identifier {
	return Identifier({{.Receiver}}[:IdentifierLength])
}

var (
	// {{.Name}}Aliases contains a dictionary of identifiers associated to their human-readable alias.
	{{.Name}}Aliases = make(map[{{.Name}}]string)

	// {{firstLower .Name}}AliasesMutex is the mutex that is used to synchronize access to the previous map.
	{{firstLower .Name}}AliasesMutex = sync.RWMutex{}
)

// RegisterAlias allows to register a human-readable alias for the Identifier which will be used as a replacement for
// the String method.
func ({{.Receiver}} {{.Name}}) RegisterAlias(alias string) {
	{{firstLower .Name}}AliasesMutex.Lock()
	defer {{firstLower .Name}}AliasesMutex.Unlock()

	{{.Name}}Aliases[{{.Receiver}}] = alias
}

// Alias returns the human-readable alias of the Identifier (or the base58 encoded bytes of no alias was set).
func ({{.Receiver}} {{.Name}}) Alias() (alias string) {
	{{firstLower .Name}}AliasesMutex.RLock()
	defer {{firstLower .Name}}AliasesMutex.RUnlock()

	if existingAlias, exists := {{.Name}}Aliases[{{.Receiver}}]; exists {
		return existingAlias
	}

	return {{.Receiver}}.ToHex()
}

// UnregisterAlias allows to unregister a previously registered alias.
func ({{.Receiver}} {{.Name}}) UnregisterAlias() {
	{{firstLower .Name}}AliasesMutex.Lock()
	defer {{firstLower .Name}}AliasesMutex.Unlock()

	delete({{.Name}}Aliases, {{.Receiver}})
}

// Compare compares two {{.Name}}s.
func ({{.Receiver}} {{.Name}}) Compare(other {{.Name}}) int {
	return bytes.Compare({{.Receiver}}[:], other[:])
}

{{if index .Features "ids"}}

type {{.Name}}s []{{.Name}}

// ToHex converts the {{.Name}}s to their hex representation.
func (ids {{.Name}}s) ToHex() []string {
	hexIDs := make([]string, len(ids))
	for i, {{.Receiver}} := range ids {
		hexIDs[i] = hexutil.EncodeHex({{.Receiver}}[:])
	}

	return hexIDs
}

// RemoveDupsAndSort removes duplicated {{.Name}}s and sorts the slice by the lexical ordering.
func (ids {{.Name}}s) RemoveDupsAndSort() {{.Name}}s {
	sorted := append({{.Name}}s{}, ids...)
	sort.Slice(sorted, func(i, j int) bool {
		return bytes.Compare(sorted[i][:], sorted[j][:]) == -1
	})

	var result {{.Name}}s
	var prev {{.Name}}
	for i, {{.Receiver}} := range sorted {
		if i == 0 || !bytes.Equal(prev[:], {{.Receiver}}[:]) {
			result = append(result, {{.Receiver}})
		}
		prev = {{.Receiver}}
	}

	return result
}

// Sort sorts the {{.Name}}s lexically and in-place.
func (ids {{.Name}}s) Sort() {
	sort.Slice(ids, func(i, j int) bool {
		return ids[i].Compare(ids[j]) < 0
	})
}

// {{.Name}}sFromHexString converts the given block IDs from their hex to {{.Name}} representation.
func {{.Name}}sFromHexString({{.Name}}sHex []string) ({{.Name}}s, error) {
	result := make({{.Name}}s, len({{.Name}}sHex))

	for i, hexString := range {{.Name}}sHex {
		{{.Name}}, err := {{.Name}}FromHexString(hexString)
		if err != nil {
			return nil, err
		}
		result[i] = {{.Name}}
	}

	return result, nil
}
{{end}}
