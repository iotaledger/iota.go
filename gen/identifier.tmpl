package iotago

// Code generated by go generate; DO NOT EDIT. Check gen/ directory instead.

import (
	"encoding/hex"
	"sync"

	"golang.org/x/crypto/blake2b"

	"github.com/iotaledger/hive.go/ierrors"
	"github.com/iotaledger/iota.go/v4/hexutil"
)

const (
	// {{.Name}}Length defines the length of an {{.Name}}.
    {{.Name}}Length = blake2b.Size256
)

var (
	Empty{{.Name}} = {{.Name}}{}

	ErrInvalid{{.Name}}Length = ierrors.New("invalid {{.Name}} length")
)

// {{.Name}} is a 32 byte hash value.
type {{.Name}} [{{.Name}}Length]byte

type {{.Name}}s []{{.Name}}

// {{.Name}}FromData returns a new {{.Name}} for the given data by hashing it with blake2b.
func {{.Name}}FromData(data []byte) {{.Name}} {
	return blake2b.Sum256(data)
}

// {{.Name}}FromHexString converts the hex to an {{.Name}} representation.
func {{.Name}}FromHexString(hex string) ({{.Name}}, error) {
	bytes, err := hexutil.DecodeHex(hex)
	if err != nil {
		return Empty{{.Name}}, err
	}

	{{.Receiver}}, _, err := {{.Name}}FromBytes(bytes)

	return {{.Receiver}}, err
}

// Must{{.Name}}FromHexString converts the hex to an {{.Name}} representation.
func Must{{.Name}}FromHexString(hex string) {{.Name}} {
	{{.Receiver}}, err := {{.Name}}FromHexString(hex)
	if err != nil {
		panic(err)
	}

	return {{.Receiver}}
}

func {{.Name}}FromBytes(bytes []byte) ({{.Name}}, int, error) {
	var {{.Receiver}} {{.Name}}
	if len(bytes) < {{.Name}}Length {
		return {{.Receiver}}, 0, ErrInvalid{{.Name}}Length
	}
	copy({{.Receiver}}[:], bytes)

	return {{.Receiver}}, len(bytes), nil
}

func ({{.Receiver}} {{.Name}}) Bytes() ([]byte, error) {
	return {{.Receiver}}[:], nil
}

func ({{.Receiver}} {{.Name}}) MarshalText() (text []byte, err error) {
	dst := make([]byte, hex.EncodedLen(len(Empty{{.Name}})))
	hex.Encode(dst, {{.Receiver}}[:])

	return dst, nil
}

func ({{.Receiver}} *{{.Name}}) UnmarshalText(text []byte) error {
	_, err := hex.Decode({{.Receiver}}[:], text)

	return err
}

// Empty tells whether the {{.Name}} is empty.
func ({{.Receiver}} {{.Name}}) Empty() bool {
	return {{.Receiver}} == Empty{{.Name}}
}

// ToHex converts the {{.Name}} to its hex representation.
func ({{.Receiver}} {{.Name}}) ToHex() string {
	return hexutil.EncodeHex({{.Receiver}}[:])
}

func ({{.Receiver}} {{.Name}}) String() string {
	return {{.Receiver}}.Alias()
}

var (
	// {{firstLower .Name}}Aliases contains a dictionary of {{.Name}}s associated to their human-readable alias.
	{{firstLower .Name}}Aliases = make(map[{{.Name}}]string)

	// {{firstLower .Name}}AliasesMutex is the mutex that is used to synchronize access to the previous map.
	{{firstLower .Name}}AliasesMutex = sync.RWMutex{}
)

// RegisterAlias allows to register a human-readable alias for the {{.Name}} which will be used as a replacement for
// the String method.
func ({{.Receiver}} {{.Name}}) RegisterAlias(alias string) {
	{{firstLower .Name}}AliasesMutex.Lock()
	defer {{firstLower .Name}}AliasesMutex.Unlock()

	{{firstLower .Name}}Aliases[{{.Receiver}}] = alias
}

// Alias returns the human-readable alias of the {{.Name}} (or the hex encoded bytes if no alias was set).
func ({{.Receiver}} {{.Name}}) Alias() (alias string) {
	{{firstLower .Name}}AliasesMutex.RLock()
	defer {{firstLower .Name}}AliasesMutex.RUnlock()

	if existingAlias, exists := {{firstLower .Name}}Aliases[{{.Receiver}}]; exists {
		return existingAlias
	}

	return {{.Receiver}}.ToHex()
}

// UnregisterAlias allows to unregister a previously registered alias.
func ({{.Receiver}} {{.Name}}) UnregisterAlias() {
	{{firstLower .Name}}AliasesMutex.Lock()
	defer {{firstLower .Name}}AliasesMutex.Unlock()

	delete({{firstLower .Name}}Aliases, {{.Receiver}})
}

// Unregister{{.Name}}Aliases allows to unregister all previously registered aliases.
func Unregister{{.Name}}Aliases() {
	{{firstLower .Name}}AliasesMutex.Lock()
	defer {{firstLower .Name}}AliasesMutex.Unlock()

	{{firstLower .Name}}Aliases = make(map[{{.Name}}]string)
}

{{if index .Features "chainid"}}
// Matches checks whether other matches this ChainID.
func ({{.Receiver}} {{.Name}}) Matches(other ChainID) bool {
	other{{.Name}}, is{{.Name}} := other.({{.Name}})
	if !is{{.Name}} {
		return false
	}

	return a == other{{.Name}}
}

// Addressable tells whether this ChainID can be converted into a ChainAddress.
func ({{.Receiver}} {{.Name}}) Addressable() bool {
	return true
}

// ToAddress converts this ChainID into an ChainAddress.
func ({{.Receiver}} {{.Name}}) ToAddress() ChainAddress {
	var addr {{.AddressType}}
	copy(addr[:], a[:])

	return &addr
}

// Key returns a key to use to index this ChainID.
func ({{.Receiver}} {{.Name}}) Key() interface{} {
	return a.String()
}

// FromOutputID returns the ChainID computed from a given OutputID.
func ({{.Receiver}} {{.Name}}) FromOutputID(in OutputID) ChainID {
	return {{.Name}}FromOutputID(in)
}

// {{.Name}}FromOutputID returns the {{.Name}} computed from a given OutputID.
func {{.Name}}FromOutputID(outputID OutputID) {{.Name}} {
	return blake2b.Sum256(outputID[:])
}{{end}}