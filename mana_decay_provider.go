package iotago

import (
	"fmt"
	"math"

	"github.com/iotaledger/hive.go/core/safemath"
	"github.com/iotaledger/hive.go/ierrors"
	"github.com/iotaledger/hive.go/lo"
)

// ManaDecayProvider calculates the mana decay and mana generation
// using fixed point arithmetic and a precomputed lookup table.
type ManaDecayProvider struct {
	timeProvider *TimeProvider

	// slotsPerEpochExponent is the number of slots in an epoch expressed as an exponent of 2.
	// (2**SlotsPerEpochExponent) == slots in an epoch.
	slotsPerEpochExponent uint64

	// bitsCount is the number of bits used to represent Mana.
	bitsCount uint64

	// generationRate is the amount of potential Mana generated by 1 IOTA in 1 slot.
	generationRate uint64 // the generation rate needs to be scaled by 2^-generationRateExponent

	// generationRateExponent is the scaling of generationRate expressed as an exponent of 2.
	generationRateExponent uint64

	// decayFactors is a lookup table of epoch index diff to mana decay factor (slice index 0 = 1 epoch).
	decayFactors []uint64 // the factors need to be scaled by 2^-decayFactorsExponent

	// decayFactorsLength is the length of the decayFactors lookup table.
	decayFactorsLength uint64

	// decayFactorsExponent is the scaling of decayFactors expressed as an exponent of 2.
	decayFactorsExponent uint64

	// decayFactorEpochsSum is an integer approximation of the sum of decay over epochs.
	decayFactorEpochsSum uint64 // the factor needs to be scaled by 2^-decayFactorEpochsSumExponent

	// decayFactorEpochsSumExponent is the scaling of decayFactorEpochsSum expressed as an exponent of 2.
	decayFactorEpochsSumExponent uint64
}

func NewManaDecayProvider(
	timeProvider *TimeProvider,
	slotsPerEpochExponent uint8,
	manaStructure *ManaStructure,
) *ManaDecayProvider {
	return &ManaDecayProvider{
		timeProvider:                 timeProvider,
		slotsPerEpochExponent:        uint64(slotsPerEpochExponent),
		bitsCount:                    uint64(manaStructure.BitsCount),
		generationRate:               uint64(manaStructure.GenerationRate),
		generationRateExponent:       uint64(manaStructure.GenerationRateExponent),
		decayFactors:                 lo.Map(manaStructure.DecayFactors, func(factor uint32) uint64 { return uint64(factor) }),
		decayFactorsLength:           uint64(len(manaStructure.DecayFactors)),
		decayFactorsExponent:         uint64(manaStructure.DecayFactorsExponent),
		decayFactorEpochsSum:         uint64(manaStructure.DecayFactorEpochsSum),
		decayFactorEpochsSumExponent: uint64(manaStructure.DecayFactorEpochsSumExponent),
	}
}

// decay performs mana decay without mana generation.
func (p *ManaDecayProvider) decay(value Mana, epochDiff EpochIndex) Mana {
	if value == 0 || epochDiff == 0 || p.decayFactorsLength == 0 {
		// no need to decay if the epoch index didn't change or no decay factors were given
		return value
	}

	// we keep applying the decay as long as epoch index diffs are left
	remainingEpochDiff := epochDiff
	for remainingEpochDiff > 0 {
		// we can't decay more than the available epoch index diffs
		// in the lookup table in this iteration
		diffsToDecay := remainingEpochDiff
		if diffsToDecay > EpochIndex(p.decayFactorsLength) {
			diffsToDecay = EpochIndex(p.decayFactorsLength)
		}
		remainingEpochDiff -= diffsToDecay

		// slice index 0 equals epoch index diff 1
		decayFactor := p.decayFactors[diffsToDecay-1]

		// apply the decay and scale the resulting value (fixed-point arithmetics)
		aux, _ := safemath.Safe64MulShift(uint64(value), decayFactor, p.decayFactorsExponent)
		value = Mana(aux)
	}

	// combine both uint64 variables to get the actual value
	return value
}

// generateMana calculates the generated mana.
func (p *ManaDecayProvider) generateMana(value BaseToken, slotDiff SlotIndex) Mana {
	if slotDiff == 0 || p.generationRate == 0 {
		return 0
	}
	aux, _ := safemath.Safe64MulShift(uint64(value), uint64(slotDiff)*p.generationRate, p.generationRateExponent)
	return Mana(aux)
}

// ManaWithDecay applies the decay to the given mana.
func (p *ManaDecayProvider) ManaWithDecay(storedMana Mana, creationSlot SlotIndex, targetSlot SlotIndex) (Mana, error) {
	creationEpoch := p.timeProvider.EpochFromSlot(creationSlot)
	targetEpoch := p.timeProvider.EpochFromSlot(targetSlot)

	if creationEpoch > targetEpoch {
		return 0, ierrors.Wrapf(ErrWrongEpochIndex, "the created epoch index was bigger than the target epoch index: %d > %d", creationEpoch, targetEpoch)
	}

	return p.decay(storedMana, targetEpoch-creationEpoch), nil
}

// ManaGenerationWithDecay calculates the generated mana and applies the decay to the result.
func (p *ManaDecayProvider) ManaGenerationWithDecay(amount BaseToken, creationSlot SlotIndex, targetSlot SlotIndex) (Mana, error) {
	creationEpoch := p.timeProvider.EpochFromSlot(creationSlot)
	targetEpoch := p.timeProvider.EpochFromSlot(targetSlot)

	if creationSlot > targetSlot {
		return 0, ierrors.Wrapf(ErrWrongEpochIndex, "the created slot index was bigger than the target slot index: %d > %d", creationSlot, targetSlot)
	}

	epochDiff := targetEpoch - creationEpoch

	//nolint:exhaustive // false-positive, we have default case
	switch epochDiff {
	case 0:
		return p.generateMana(amount, targetSlot-creationSlot), nil

	case 1:
		manaDecayed := p.decay(p.generateMana(amount, p.timeProvider.SlotsBeforeNextEpoch(creationSlot)), 1)
		manaGenerated := p.generateMana(amount, p.timeProvider.SlotsSinceEpochStart(targetSlot))
		return safemath.SafeAdd(manaDecayed, manaGenerated)

	default:
		aux, _ := safemath.Safe64MulShift(uint64(amount), p.decayFactorEpochsSum*p.generationRate, p.decayFactorEpochsSumExponent+p.generationRateExponent-p.slotsPerEpochExponent)
		c := Mana(aux)
		//nolint:golint,revive,nosnakecase,stylecheck // taken from the formula, lets keep it that way
		potentialMana_n := p.decay(p.generateMana(amount, p.timeProvider.SlotsBeforeNextEpoch(creationSlot)), epochDiff)

		//nolint:golint,revive,nosnakecase,stylecheck // taken from the formula, lets keep it that way
		potentialMana_n_1 := p.decay(c, epochDiff-1)

		//nolint:golint,revive,nosnakecase,stylecheck // taken from the formula, lets keep it that way
		potentialMana_0, err := safemath.SafeAdd(c, p.generateMana(amount, p.timeProvider.SlotsSinceEpochStart(targetSlot)))
		if err != nil {
			return 0, err
		}

		potentialMana_0, err = safemath.SafeSub(potentialMana_0, c>>p.decayFactorsExponent)
		if err != nil {
			return 0, err
		}

		// result = potentialMana_0 - potentialMana_n_1 + potentialMana_n
		//nolint:golint,revive,nosnakecase,stylecheck // taken from the formula, lets keep it that way
		result, err := safemath.SafeSub(potentialMana_0, potentialMana_n_1)
		if err != nil {
			return 0, err
		}
		printVar, _ := safemath.SafeAdd(result, potentialMana_n)
		//nolint:golint,revive,nosnakecase,stylecheck // taken from the formula, lets keep it that way
		fmt.Println(p.LowerBoundPotentialMana(amount, creationSlot, targetSlot), printVar, p.UpperBoundPotentialMana(amount, creationSlot, targetSlot))
		return safemath.SafeAdd(result, potentialMana_n)
	}
}

// RewardsWithDecay applies the decay to the given stored mana.
func (p *ManaDecayProvider) RewardsWithDecay(rewards Mana, rewardEpoch EpochIndex, claimedEpoch EpochIndex) (Mana, error) {
	if rewardEpoch > claimedEpoch {
		return 0, ierrors.Wrapf(ErrWrongEpochIndex, "the reward epoch index was bigger than the claiming epoch index: %d > %d", rewardEpoch, claimedEpoch)
	}

	return p.decay(rewards, claimedEpoch-rewardEpoch), nil
}

func (p *ManaDecayProvider) ExactResultPotentialMana(amount BaseToken, creationSlot SlotIndex, targetSlot SlotIndex) float64 {
	creationEpoch := p.timeProvider.EpochFromSlot(creationSlot)
	targetEpoch := p.timeProvider.EpochFromSlot(targetSlot)
	floatAmount := float64(amount)
	floatGenRate := float64(p.generationRate) * math.Pow(2, -float64(p.generationRateExponent))
	delta := float64(1<<13) * (1.0 / (365.0 * 24.0 * 60.0 * 60.0)) * float64(10)
	epochDiff := targetEpoch - creationEpoch

	switch epochDiff {
	case 0:
		floatSlotDiff := float64(targetSlot - creationSlot)
		return floatSlotDiff * floatAmount * floatGenRate
	case 1:
		slotsBeforeNextEpoch := p.timeProvider.SlotsBeforeNextEpoch(creationSlot)
		slotsSinceEpochStart := p.timeProvider.SlotsSinceEpochStart(targetSlot)
		manaDecayed := float64(slotsBeforeNextEpoch) * floatAmount * floatGenRate * math.Exp(-delta/3)
		manaGenerated := float64(slotsSinceEpochStart) * floatAmount * floatGenRate
		return manaDecayed + manaGenerated
	default:
		slotsBeforeNextEpoch := p.timeProvider.SlotsBeforeNextEpoch(creationSlot)
		slotsSinceEpochStart := p.timeProvider.SlotsSinceEpochStart(targetSlot)
		epochDiffFloat := float64(epochDiff)
		slotsPerEpochFloat := math.Pow(2, 13)
		constant := math.Exp(-delta/3) * (1 - math.Exp(-(epochDiffFloat-1)*delta/3)) / (1 - math.Exp(-delta/3))
		potentialMana_n := float64(slotsBeforeNextEpoch) * floatAmount * floatGenRate * math.Exp(-epochDiffFloat*delta/3)
		potentialMana_n_1 := constant * floatAmount * floatGenRate * slotsPerEpochFloat
		potentialMana_0 := float64(slotsSinceEpochStart) * floatAmount * floatGenRate
		return potentialMana_n + potentialMana_n_1 + potentialMana_0
	}
}

func (p *ManaDecayProvider) LowerBoundPotentialMana(amount BaseToken, creationSlot SlotIndex, targetSlot SlotIndex) float64 {
	delta := float64(1<<13) * (1.0 / (365.0 * 24.0 * 60.0 * 60.0)) * float64(10)
	constant := math.Exp(-delta/3) / (1 - math.Exp(-delta/3))
	return p.ExactResultPotentialMana(amount, creationSlot, targetSlot) - (4 + float64(amount)*math.Pow(2, float64(13-27))*(1+constant*math.Pow(2, -float64(32))))
}

func (p *ManaDecayProvider) UpperBoundPotentialMana(amount BaseToken, creationSlot SlotIndex, targetSlot SlotIndex) float64 {
	return p.ExactResultPotentialMana(amount, creationSlot, targetSlot) + 2 - math.Pow(2, -float64(32-1))
}
